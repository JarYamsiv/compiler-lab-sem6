structure Translate =
struct

val red = "\u001b[31;1m"
val green = "\u001b[32;1m"
val white = "\u001b[37;1m"
val yellow = "\u001b[33;1m"
val grey = "\u001b[30;1m"
val reset = "\u001b[0m"

exception undef

structure SymTabKey = 
struct
	type ord_key = Atom.atom
	type tab_content = int
	val compare = Atom.compare
end

structure SymTable = MakeSymTable(SymTabKey)

fun addtabs n = if n <= 0 then
					("")
				else
					("   "^( addtabs (n-1)) )


(**************************************************************************************************************************************)
(**************************************************************************************************************************************)
(**************************************************COMPILE  EXPRESSION*****************************************************************)
(**************************************************************************************************************************************)
(**************************************************************************************************************************************)


fun compileExpr (Ast.Const x )         = (" "^(Int.toString x)^" ")

  | compileExpr (Ast.EVar  x )		   = let 
  											val _ = case SymTable.checkkey(Atom.atom x) of true => () | false => (raise undef)
  										 in(x)end	

  | compileExpr (Ast.ARVar  (x,e) )		   = let 
  											val _ = case SymTable.checkkey(Atom.atom x) of true => () | false => (raise undef)
  										 in(x^"["^(compileExpr e)^"]")end
  
  | compileExpr (Ast.Op (x, oper, y))  = ((compileExpr x) ^ (Ast.binOpToString oper) ^ (compileExpr y ))





(**************************************************************************************************************************************)
(**************************************************************************************************************************************)
(***************************************************COMPILE  CONDITION*****************************************************************)
(**************************************************************************************************************************************)
(**************************************************************************************************************************************)



fun compileCondition (Ast.CConst x)	  = (" "^(Int.toString x)^" ")

  | compileCondition (Ast.CVar  x)		  = let
  												val _ = case SymTable.checkkey(Atom.atom x) of true => () | false => (raise undef)
  											in(" "^x^" ")end

  | compileCondition (Ast.CondOp (x,oper,y)) = ((compileCondition x) ^ (Ast.condOpToString oper) ^ (compileCondition y))




(**************************************************************************************************************************************)
(**************************************************************************************************************************************)
(*****************************************COMPILE STATEMENT AND STATEMENTS*************************************************************)
(**************************************************************************************************************************************)
(**************************************************************************************************************************************)


fun    compileStatement (Ast.As (x,exp))	t  		=
	let 
		val ret = (  
			case (SymTable.checkkey(Atom.atom x)) of
			true => ( (addtabs t) ^  (x^" = ") ^ (compileExpr exp) ^ (";\n") )
			|false => ( (addtabs t) ^  ("int "^x^" = ") ^ (compileExpr exp) ^ (";\n") ) 
			)
	in
		SymTable.addkey(Atom.atom x,0);ret
	end


	| compileStatement (Ast.Ret exp)         t  = ( (addtabs t) ^ "return" ^(compileExpr exp)^ ";\n" )



	| compileStatement (Ast.FnCl x)		t  		=  ( (addtabs t) ^  (x^"();\n")  )
	| compileStatement (Ast.If (c,sl))		  t =	(
														(addtabs t) ^ ("if(") ^ (compileCondition c) ^  ("){\n") ^
														(compileStatements (t+1,sl) ) ^
														(addtabs t) ^ ("}\n")
													)	
	| compileStatement (Ast.IfEl (c,sl1,sl2)) t =	(
														(addtabs t) ^  ("if(") ^ (compileCondition c) ^  ("){\n") ^

														(compileStatements (t+1,sl1)) ^

														(addtabs t) ^ ("}\n") ^

														(addtabs t) ^  ("else{\n") ^

														(compileStatements (t+1,sl2) )^

														(addtabs t )^ ("}\n")
													)



and  compileStatements  (t,(x :: xs))	  = ((compileStatement x t)^(compileStatements (t,xs)))
	|compileStatements  (t,[])	   		  = ("")




(**************************************************************************************************************************************)
(**************************************************************************************************************************************)
(************************************************COMPILE FUNCTION**********************************************************************)
(**************************************************************************************************************************************)
(**************************************************************************************************************************************)

fun compileFun(Ast.Fun (x,g))		t  =  (
											("fun "^x^"(){\n")^
											(compileStatements  (t+1,g) )^
											 ("}\n")
											 )





(**************************************************************************************************************************************)
(**************************************************************************************************************************************)
(***************************************************COMPILE PROGRAM ELEMENT************************************************************)
(**************************************************************************************************************************************)
(**************************************************************************************************************************************)

fun   compileElem (Ast.St statement)	  = compileStatement statement 0	
	| compileElem (Ast.Fn function)       = (compileFun  function 0) 





(**************************************************************************************************************************************)
(**************************************************************************************************************************************)
(**************************************************COMPILE*****************************************************************************)
(**************************************************************************************************************************************)
(**************************************************************************************************************************************)

fun compile []        = ("")
  | compile (x :: xs) = ((compileElem x)^(compile xs))

end
